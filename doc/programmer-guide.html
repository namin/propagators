<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Programming with Propagators</title>
<style type="text/css">

@import url(html4css1.css);

body {
  background: white;
  font-family: verdana, arial, helvetica, sans-serif;
  margin: 0px;
  padding: 6px;
}

h1, h2 {
  color: #333333;
  margin-top: 0px;
  margin-bottom: 0px;
  padding-top: 0.0em;
}

p {
  margin-top: 0.5em;
  text-align: justify;
}

.document {
  max-width: 50em;
  margin: 0 auto;
}

/* People list */
.people { overflow: auto; }
.person {
  float: left;
  text-align: center;
  padding: .5em;
  width: 160px;
  height: 180px;
}
.person img { height: 120px; }
.person .name { font-weight: bold; }
.person { font-size: 80%; }

</style>
</head>
<body>
<div class="document" id="programming-with-propagators">
<h1 class="title">Programming with Propagators</h1>

<p>Scheme-Propagators, pending a better name, is a prototype
propagator-oriented programming language embedded in Scheme.
Scheme-Propagators is also the name of the only extant implementation.
The purpose of this document is to teach you how to write and run
propagator programs in Scheme-Propagators for fun and profit.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#audience" id="id2">Audience</a></li>
<li><a class="reference internal" href="#getting-started" id="id3">Getting Started</a></li>
<li><a class="reference internal" href="#organizing-principle" id="id4">Organizing Principle</a></li>
<li><a class="reference internal" href="#making-propagator-networks" id="id5">Making Propagator Networks</a><ul>
<li><a class="reference internal" href="#attaching-basic-propagators-p-foo-and-e-foo" id="id6">Attaching Basic Propagators: p:foo and e:foo</a></li>
<li><a class="reference internal" href="#attaching-propagator-constraints-c-foo-and-ce-foo" id="id7">Attaching Propagator Constraints: c:foo and ce:foo</a></li>
<li><a class="reference internal" href="#constants-and-literal-values" id="id8">Constants and Literal Values</a></li>
<li><a class="reference internal" href="#making-cells" id="id9">Making Cells</a></li>
</ul>
</li>
<li><a class="reference internal" href="#making-new-compound-propagators" id="id10">Making New Compound Propagators</a><ul>
<li><a class="reference internal" href="#recursion" id="id11">Recursion</a></li>
<li><a class="reference internal" href="#expressions" id="id12">Expressions</a></li>
<li><a class="reference internal" href="#macrology" id="id13">Macrology</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-partial-information" id="id14">Using Partial Information</a></li>
<li><a class="reference internal" href="#making-new-kinds-of-partial-information" id="id15">Making New Kinds of Partial Information</a><ul>
<li><a class="reference internal" href="#define-your-merge-handlers" id="id16">Define your Merge Handlers</a></li>
<li><a class="reference internal" href="#define-your-contradiction-test" id="id17">Define your Contradiction Test</a></li>
<li><a class="reference internal" href="#augment-the-propagators" id="id18">Augment the Propagators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#debugging" id="id19">Debugging</a></li>
<li><a class="reference internal" href="#making-new-primitive-propagators" id="id20">Making New Primitive Propagators</a><ul>
<li><a class="reference internal" href="#direct-construction-from-functions" id="id21">Direct Construction from Functions</a><ul>
<li><a class="reference internal" href="#propagator-constructor-combinators" id="id22">Propagator Constructor Combinators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dwim-propagator-construction" id="id23">DWIM Propagator Construction</a></li>
<li><a class="reference internal" href="#fully-manual-low-level-propagator-construction" id="id24">Fully-manual Low-level Propagator Construction</a></li>
</ul>
</li>
<li><a class="reference internal" href="#miscellany" id="id25">Miscellany</a><ul>
<li><a class="reference internal" href="#implicit-cell-syntax" id="id26">Implicit Cell Syntax</a></li>
<li><a class="reference internal" href="#reboots" id="id27">Reboots</a></li>
<li><a class="reference internal" href="#compiling" id="id28">Compiling</a></li>
<li><a class="reference internal" href="#scmutils" id="id29">Scmutils</a></li>
<li><a class="reference internal" href="#editing" id="id30">Editing</a></li>
<li><a class="reference internal" href="#hacking" id="id31">Hacking</a></li>
<li><a class="reference internal" href="#todo" id="id32">TODO</a></li>
<li><a class="reference internal" href="#revision-history-of-this-guide" id="id33">Revision History of this Guide</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="audience">
<h1><a class="toc-backref" href="#id2">Audience</a></h1>
<p>I assume you are very excited to try your hand at programming with
propagators, either on this system or on one you intend to build for
yourself using what I learned building this one as a guide.  Otherwise
why would you be reading the programming guide of a prototype
propagator programming language?  I will therefore expend no effort to
convince you that propagators are awesome.</p>
<p>I assume you read the <a class="reference external" href="http://dspace.mit.edu/handle/1721.1/44215">Art of the Propagator</a> paper and/or the
<a class="reference external" href="http://dspace.mit.edu/handle/1721.1/49525">Propagation Networks</a> PhD dissertation.  Otherwise, I fear you will
have no idea what I'm talking about in this document.  Be advised,
though, that the actual mechanics of the Scheme-Propagators system
have evolved somewhat since those were published.</p>
<p>I assume you are familiar with the Scheme programming language.  If
you're not, you should go learn it --- it's a wonderful programming
language --- but I cannot teach it to you here; and Scheme-Propagators
is inseparably intertwined with Scheme, so you will need to know
Scheme both to get anything out of reading this document and to
program Scheme-Propagators.</p>
<p>I assume you are not afraid to read the source code.  This document is
meant to give you the overview and introduction, and get you started,
but Scheme-Propagators is a prototype.  You will need to look under
the covers eventually, both to understand in detail how things work,
and to do the sophisticated things I expect you may come to want to
do.  Scheme-Propagators is also a work in progress.  Documentation
goes stale, but the code is always right (especially when the test
suite passes).</p>
<p>Finally, I assume you know who I am.  Scheme-Propagators is enough a
prototype that I can make no guarantees about your mileage with it
unless you are in range to ask me questions.</p>
</div>
<div class="section" id="getting-started">
<h1><a class="toc-backref" href="#id3">Getting Started</a></h1>
<p>Scheme-Propagators is implemented in <a class="reference external" href="http://www.gnu.org/software/mit-scheme/">MIT/GNU Scheme</a>, which you will
need in order to use it.  You will also need Scheme-Propagators
itself, which you can check out from the <a class="reference external" href="git&#64;github.com:MIT-MMP/propagator.git">MMP git archive</a>.  Once you
have it, go to the <tt class="docutils literal"><span class="pre">propagator/</span></tt> directory, start up your Scheme and
load the main entry file with <tt class="docutils literal"><span class="pre">(load</span> <span class="pre">&quot;load&quot;)</span></tt>.  This gives you a
read-eval-print loop (traditionally called a REPL for short) for both
the Scheme-Propagators system and the underlying Scheme
implementation.  Check out the README for more on this.
TODO Real releases?  From a real web place?</p>
<p>Once you've got your REPL, you can start typing away at it to create
propagator networks, give them inputs, ask them to do computations,
and look at the results.</p>
<p>Here's a little propagator example that adds two and three to get
five:</p>
<pre class="literal-block">
(define-cell a)
(define-cell b)
(add-content a 3)
(add-content b 2)
(define-cell answer (e:+ a b))
(run)
(content answer) ==&gt; 5
</pre>
<p>Each of the parenthesized phrases above are things to type into
the REPL, and the <tt class="docutils literal"><span class="pre">==&gt;</span> <span class="pre">5</span></tt> at the end is the result that Scheme
will print.  I omitted the results of all the other expressions
because they are not interesting.</p>
<p>Let's have a closer look at what's going on in this example,
to serve as a guide for more in-depth discussion later.
<tt class="docutils literal"><span class="pre">define-cell</span></tt> is a Scheme macro for making and naming propagator
cells:</p>
<pre class="literal-block">
(define-cell a)
</pre>
<p>creates a new cell and binds it to the Scheme variable <tt class="docutils literal"><span class="pre">a</span></tt>.</p>
<pre class="literal-block">
(define-cell b)
</pre>
<p>makes another one.  Then <tt class="docutils literal"><span class="pre">add-content</span></tt> is the Scheme procedure that
directly zaps some information into a propagator cell (all the
propagators use it to talk to the cells, and you can too).  So:</p>
<pre class="literal-block">
(add-content a 3)
</pre>
<p>puts a <tt class="docutils literal"><span class="pre">3</span></tt> into the cell named <tt class="docutils literal"><span class="pre">a</span></tt>, and:</p>
<pre class="literal-block">
(add-content b 2)
</pre>
<p>puts a <tt class="docutils literal"><span class="pre">2</span></tt> into the cell named <tt class="docutils literal"><span class="pre">b</span></tt>.  Now <tt class="docutils literal"><span class="pre">e:+</span></tt> (I'll explain
that naming convention later) is a Scheme procedure that creates
a propagator that adds, attaches it to the given cells as inputs,
and makes a cell to hold the adder's output and returns it.  So:</p>
<pre class="literal-block">
(define-cell answer (e:+ a b))
</pre>
<p>creates an adding propagator, and also creates a cell, now called
<tt class="docutils literal"><span class="pre">answer</span></tt>, to hold the result of the addition.  Be careful!  No
computation has happened yet.  You've just made up a network, but it
hasn't done its work yet.  That's what the Scheme procedure <tt class="docutils literal"><span class="pre">run</span></tt> is
for:</p>
<pre class="literal-block">
(run)
</pre>
<p>actually executes the network, and only when the network is done
computing does it give you back the REPL to interact with.  Finally
<tt class="docutils literal"><span class="pre">content</span></tt> is a Scheme procedure that gets the content of cells:</p>
<pre class="literal-block">
(content answer)
</pre>
<p>looks at what the cell named <tt class="docutils literal"><span class="pre">answer</span></tt> has now, which is <tt class="docutils literal"><span class="pre">5</span></tt>
because the addition propagator created by <tt class="docutils literal"><span class="pre">e:+</span></tt> has had a chance to
do its job.  If you had forgotten to type <tt class="docutils literal"><span class="pre">(run)</span></tt> before typing
<tt class="docutils literal"><span class="pre">(content</span> <span class="pre">answer)</span></tt>, it would have printed out <tt class="docutils literal"><span class="pre">#(*the-nothing*)</span></tt>,
which means that cell has no information about the value it is meant
to have.</p>
</div>
<div class="section" id="organizing-principle">
<h1><a class="toc-backref" href="#id4">Organizing Principle</a></h1>
<p>The two major aspects of a propagator-oriented programming language,
at least as I currently envision such a thing, are propagator networks
and the partial information structures they manipulate.  It feels like
&quot;programming&quot; is primarily about creating propagator networks;
inventing and implementing good partial information types seems to be
more of a library writer's kind of job, though one you will most
likely also need to engage in if you want to get anything done with
Scheme-Propagators as it currently stands.  We will therefore talk
about making networks first, and about making partial information
types later.  Also, making propagator networks is more different from
the normal programming you are used to than is creating partial
information types, and so the way to do that is more of a new
&quot;language&quot;.</p>
<p>The &quot;read and syntax&quot; phase of programming a network in
Scheme-Propagators is the &quot;read and eval&quot; phase of the host Scheme;
with the understanding that all Scheme variables that get bound to
cells are propagator variables, and all Scheme variables that get
bound to other Scheme objects are &quot;syntax&quot; from the perspective of
Scheme-Propagators.  Things that can live in cells are the first-class
entities of Scheme-Propagators, and other things from the host Scheme
are second-class as far as the Scheme-Propagators langauge is
concerned.</p>
<p>Scheme-Propagators therefore has a &quot;macro system&quot; that is much more
developed than the propagator language itself, because MIT/GNU Scheme
is a full programming language that has been around for decades, while
Scheme-Propagators is a prototype whose name hasn't even stabilized
yet.  Thus these &quot;macros&quot; are still needed for many purposes.  Perhaps
the most egregious example is the predefined procedures: in Scheme,
<tt class="docutils literal"><span class="pre">+</span></tt> is a variable that's bound to a procedure, whereas in
Scheme-Propagators, the corresponding object <tt class="docutils literal"><span class="pre">e:+</span></tt> is a piece of
syntax (that is, the Scheme variable <tt class="docutils literal"><span class="pre">e:+</span></tt> is not bound to a cell
that holds a propagator abstraction that adds, and therefore is not a
variable of Scheme-Propagators, but is rather bound to a Scheme
procedure that directly makes a propagator that adds, and therefore is
Scheme-Propagators syntax.  More on this later).</p>
<p>Scheme-Propagators has no linguistic support for making new partial
information types.  Those are all programmed in the underlying Scheme,
with a procedural interface.  We will talk about how to do that later.</p>
</div>
<div class="section" id="making-propagator-networks">
<h1><a class="toc-backref" href="#id5">Making Propagator Networks</a></h1>
<p>The ingredients of a propagator network are cells and propagators.
The cells' job is to remember things; the propagators' job is to
compute.  The analogy is that propagators are like the procedures of a
normal programming language, and cells are like the memory locations;
the big difference, of course, is that cells accumulate partial
information (which may involve arbitrary internal computations), and
can therefore have many propagators reading information from them and
writing information to them.</p>
<p>The two basic operations when making a propagator network are making
cells and attaching propagators to cells.  You already met one way to
make cells in the form of <tt class="docutils literal"><span class="pre">define-cell</span></tt>; we will talk about more
later, but let's talk about propagators first.</p>
<div class="section" id="attaching-basic-propagators-p-foo-and-e-foo">
<h2><a class="toc-backref" href="#id6">Attaching Basic Propagators: p:foo and e:foo</a></h2>
<p>You attach propagators to cells by calling an appropriate
Scheme procedure that does that.  For example, the procedure <tt class="docutils literal"><span class="pre">p:+</span></tt> attaches
an adding propagator:</p>
<pre class="literal-block">
(p:+ foo bar baz)
</pre>
<p>means attach a propagator that will add the contents of the cells
<tt class="docutils literal"><span class="pre">foo</span></tt> and <tt class="docutils literal"><span class="pre">bar</span></tt> and write them into <tt class="docutils literal"><span class="pre">baz</span></tt>.  This means that
henceforth, whenever either the <tt class="docutils literal"><span class="pre">foo</span></tt> cell or the <tt class="docutils literal"><span class="pre">bar</span></tt> cell gets
any new interesting information, the appropriate sum will eventually
get computed and written into <tt class="docutils literal"><span class="pre">baz</span></tt>.</p>
<p>Note that this <tt class="docutils literal"><span class="pre">p:+</span></tt> is different from the <tt class="docutils literal"><span class="pre">e:+</span></tt> in the example at
the beginning.  This is a general naming convention.  <tt class="docutils literal"><span class="pre">p:</span></tt> stands
for &quot;propagator&quot;.  A thing named <tt class="docutils literal"><span class="pre">p:foo</span></tt> is a Scheme procedure
(therefore Scheme-Propagators syntax) that attaches a propagator that
does the <tt class="docutils literal"><span class="pre">foo</span></tt> job to a full collection of cells, one for each input
to <tt class="docutils literal"><span class="pre">foo</span></tt> and one for the output from <tt class="docutils literal"><span class="pre">foo</span></tt>.  The output cells
conventionally go last (though I am open to changing that).  In
principle the <tt class="docutils literal"><span class="pre">p:</span></tt> convention will work just as well for jobs that
have multiple outputs, but I don't actually have any of those in the
system at present.</p>
<p>In contrast, <tt class="docutils literal"><span class="pre">e:</span></tt> stands for &quot;expression&quot;.  A thing named <tt class="docutils literal"><span class="pre">e:foo</span></tt>
is a Scheme procedure (so Scheme-Propagators syntax) just like
<tt class="docutils literal"><span class="pre">p:foo</span></tt>, except that it makes a fresh cell for the output and
returns it (whereas <tt class="docutils literal"><span class="pre">p:foo</span></tt> does not return anything useful).  Here
are two different ways to write the same thing:</p>
<pre class="literal-block">
(define-cell x)
(define-cell y)
(define-cell z)
(p:* x y z)
</pre>
<p>and:</p>
<pre class="literal-block">
(define-cell x)
(define-cell y)
(define-cell z (e:* x y))
</pre>
<p>Generally the <tt class="docutils literal"><span class="pre">e:</span></tt> procedures are much more convenient to use most
of the time, when some propagator is the only one that writes to its
output; and you can chain them in the familiar way</p>
<pre class="literal-block">
(e:- w (e:* (e:+ x y) z))
</pre>
<p>but when you need to make a propagator that writes to a cell you
already have, such as when multiple propagators need to write to the
same cell, you need the <tt class="docutils literal"><span class="pre">p:</span></tt> versions.  For example, if you wanted
to be able to go back from <tt class="docutils literal"><span class="pre">z</span></tt> and one of <tt class="docutils literal"><span class="pre">x</span></tt> or <tt class="docutils literal"><span class="pre">y</span></tt> to the
other, rather than just from <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> to <tt class="docutils literal"><span class="pre">z</span></tt>, you could write:</p>
<pre class="literal-block">
(define-cell x)
(define-cell y)
(define-cell z (e:* x y))
(p:/ z x y)
(p:/ z y x)
</pre>
<p>and get a multidirectional constraint:</p>
<pre class="literal-block">
(add-content z 6)
(add-content x 3)
(run)
(content y) ==&gt; 2
</pre>
<p>TODO Provide a list of available propagator constructors. (Don't forget binary-amb and company)</p>
</div>
<div class="section" id="attaching-propagator-constraints-c-foo-and-ce-foo">
<h2><a class="toc-backref" href="#id7">Attaching Propagator Constraints: c:foo and ce:foo</a></h2>
<p>Speaking of constraints, they are so useful that many are predefined,
and they have their own naming convention.  <tt class="docutils literal"><span class="pre">c:</span></tt> stands for
&quot;constraining&quot;.  A thing named <tt class="docutils literal"><span class="pre">c:foo</span></tt> is the constraining analogue
of <tt class="docutils literal"><span class="pre">p:foo</span></tt>, in that in addition to attaching a propagator that does
<tt class="docutils literal"><span class="pre">foo</span></tt> to its cells, it also attaches <tt class="docutils literal"><span class="pre">foo-inverse</span></tt> propagators
that deduce &quot;inputs&quot; from &quot;outputs&quot;.  For example, the product
constraint that we built in the previous section is available as
<tt class="docutils literal"><span class="pre">c:*</span></tt>:</p>
<pre class="literal-block">
(define-cell x)
(define-cell y)
(define-cell z)
(c:* x y z)

(add-content z 12)
(add-content y 4)
(run)
(content x) ==&gt; 3
</pre>
<p>The <tt class="docutils literal"><span class="pre">c:</span></tt> procedures also have expression versions::</p>
<pre class="literal-block">
(define-cell x)
(define-cell y)
(define-cell z (ce:* x y))
</pre>
<p><tt class="docutils literal"><span class="pre">ce:foo</span></tt> is to <tt class="docutils literal"><span class="pre">c:foo</span></tt> as <tt class="docutils literal"><span class="pre">e:foo</span></tt> is to <tt class="docutils literal"><span class="pre">p:foo</span></tt>.</p>
<p>Of course, not every operation has a useful inverse, so there are
fewer <tt class="docutils literal"><span class="pre">c:</span></tt> procedures defined than <tt class="docutils literal"><span class="pre">p:</span></tt>.  For the complete list see TODO.</p>
</div>
<div class="section" id="constants-and-literal-values">
<h2><a class="toc-backref" href="#id8">Constants and Literal Values</a></h2>
<p>Programs have embedded constants all the time, and propagator programs
are no different (except that constant values, like all other values,
can be partial).  We've already seen one way to put a
Scheme value into a propagator program: the <tt class="docutils literal"><span class="pre">add-content</span></tt> procedure
zaps a value straight into a cell.  This is generally encouraged at
the REPL, but frowned upon in actual programs.  It is much nicer (in
my current opinion) to use <tt class="docutils literal"><span class="pre">constant</span></tt> or <tt class="docutils literal"><span class="pre">p:constant</span></tt> (they're the
same) to make a propagator that will zap your value into your cell for
you:</p>
<pre class="literal-block">
(define-cell thing)
((constant 5) thing)
(content thing) ==&gt; #(*the-nothing*)
(run)
(content thing) ==&gt; 5
</pre>
<p>There is also an expression-oriented version, called, naturally,
<tt class="docutils literal"><span class="pre">e:constant</span></tt>:</p>
<pre class="literal-block">
(define-cell thing (e:constant 5))
(run)
(content thing) ==&gt; 5
</pre>
<p>In fact, inserting constants is so important, that there is one more
nicification of this: whenever possible, the system will convert a raw
constant (i.e. a non-cell Scheme object) into a cell, using
<tt class="docutils literal"><span class="pre">e:constant</span></tt>.
Some examples:</p>
<pre class="literal-block">
(e:+ x 2)          ==&gt;   (e:+ x (e:constant 2))
(define-cell x 4)  ==&gt;   (define-cell x (e:constant 4))
(c:+ x y 0)        ==&gt;   (c:+ x y (e:constant 0))

(define-macro-propagator (p:double x y)
  (p:+ x x y))
(p:double 4 z)     ==&gt;   (p:double (e:constant 4) z)
</pre>
</div>
<div class="section" id="making-cells">
<h2><a class="toc-backref" href="#id9">Making Cells</a></h2>
<p>In order to have something to attach propagators to, you need to have
cells.  Cells are the memory locations of the Scheme-Propagators
language; Scheme variables whose bindings are cells correspond to
Scheme-Propagators variables (Scheme variables whose bindings are
other things look like syntax to Scheme-Propagators).  You've
already met one way to make cells:</p>
<pre class="literal-block">
(define-cell x)
</pre>
<p>creates a Scheme variable named <tt class="docutils literal"><span class="pre">x</span></tt> and binds a cell to it.  The
underlying mechanism underneath this is the procedure <tt class="docutils literal"><span class="pre">make-cell</span></tt>,
which creates a cell and lets you do whatever you want with it.  So
you could write:</p>
<pre class="literal-block">
(define x (make-cell))
</pre>
<p>which would also make a Scheme variable named <tt class="docutils literal"><span class="pre">x</span></tt> and bind a cell to
it.  In fact, that is almost exactly what <tt class="docutils literal"><span class="pre">define-cell</span></tt> does, except
that <tt class="docutils literal"><span class="pre">define-cell</span></tt> attaches
some metadata to the cell it creates to make it easier to debug the
network (see below) and also does constant conversion (so <tt class="docutils literal"><span class="pre">(define-cell</span> <span class="pre">x</span>
<span class="pre">5)</span></tt> makes <tt class="docutils literal"><span class="pre">x</span></tt> a cell that will get a <tt class="docutils literal"><span class="pre">5</span></tt> put into it, whereas
<tt class="docutils literal"><span class="pre">(define</span> <span class="pre">x</span> <span class="pre">5)</span></tt> would just bind <tt class="docutils literal"><span class="pre">x</span></tt> to <tt class="docutils literal"><span class="pre">5</span></tt>).</p>
<p>Just as Scheme has several mechanisms of making variables, so
Scheme-Propagators has corresponding ones.  Corresponding to Scheme's
<tt class="docutils literal"><span class="pre">let</span></tt>, Scheme-Propagators has <tt class="docutils literal"><span class="pre">let-cells</span></tt>:</p>
<pre class="literal-block">
(let-cells ((foo (e:+ x y))
            (bar (e:* x y)))
  ...)
</pre>
<p>will create the Scheme bindings <tt class="docutils literal"><span class="pre">foo</span></tt> and <tt class="docutils literal"><span class="pre">bar</span></tt>, and bind them to
the cells made by <tt class="docutils literal"><span class="pre">(e:+</span> <span class="pre">x</span> <span class="pre">y)</span></tt> and <tt class="docutils literal"><span class="pre">(e:*</span> <span class="pre">x</span> <span class="pre">y)</span></tt>, respectively (this
code is only sensible if <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> are already bound to cells
(or subject to constant conversion)).  The new bindings will only be
visible inside the scope of the <tt class="docutils literal"><span class="pre">let-cells</span></tt>, just like in Scheme;
but if you attach propagators to them, the cells themselves will
continue to exist and function as part of your propagator network.</p>
<p>One notable difference from Scheme: a cell in a propagator network,
unlike a variable in Scheme, has a perfectly good &quot;initial state&quot;.
Every cell starts life knowing <tt class="docutils literal"><span class="pre">nothing</span></tt> about its intended
contents; where Scheme variables have to start life in a weird
&quot;unassigned&quot; state, <tt class="docutils literal"><span class="pre">nothing</span></tt> is a perfectly good partial
information structure.  This means that it's perfectly reasonable
for <tt class="docutils literal"><span class="pre">let-cells</span></tt> to make cells with no initialization forms:</p>
<pre class="literal-block">
(let-cells (x y (foo (some thing))) ...)
</pre>
<p>creates cells named <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt>, which are empty and have
no propagators attached to them initially, and also a cell
named <tt class="docutils literal"><span class="pre">foo</span></tt> like above.  <tt class="docutils literal"><span class="pre">let-cells</span></tt> also recognizes the
usage:</p>
<pre class="literal-block">
(let-cells ((x) (y) (foo (some thing))) ...)
</pre>
<p>by analogy with Scheme <tt class="docutils literal"><span class="pre">let</span></tt>.</p>
<p>Corresponding to Scheme's <tt class="docutils literal"><span class="pre">let*</span></tt>, Scheme-Propagators has <tt class="docutils literal"><span class="pre">let-cells*</span></tt>.
<tt class="docutils literal"><span class="pre">let-cells*</span></tt> is to <tt class="docutils literal"><span class="pre">let-cells</span></tt> what <tt class="docutils literal"><span class="pre">let*</span></tt> is to <tt class="docutils literal"><span class="pre">let</span></tt>:</p>
<pre class="literal-block">
(let-cells* ((x)
             (y (e:+ x x)))
  ...)
</pre>
<p>will make a cell named <tt class="docutils literal"><span class="pre">x</span></tt> and a cell named <tt class="docutils literal"><span class="pre">y</span></tt> with an adder both
of whose inputs are <tt class="docutils literal"><span class="pre">x</span></tt> and whose output is <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
<p>Now, <tt class="docutils literal"><span class="pre">let-cells</span></tt> and <tt class="docutils literal"><span class="pre">let-cells*</span></tt> are, like <tt class="docutils literal"><span class="pre">define-cell</span></tt>,
basically a convenience
over doing the same thing in Scheme with <tt class="docutils literal"><span class="pre">let</span></tt>, <tt class="docutils literal"><span class="pre">let*</span></tt> and <tt class="docutils literal"><span class="pre">make-cell</span></tt>.
Also like <tt class="docutils literal"><span class="pre">define-cell</span></tt>, <tt class="docutils literal"><span class="pre">let-cells</span></tt> and <tt class="docutils literal"><span class="pre">let-cells*</span></tt> do
constant conversion (so
in <tt class="docutils literal"><span class="pre">(let-cells</span> <span class="pre">((x</span> <span class="pre">3))</span> <span class="pre">...)</span></tt>, <tt class="docutils literal"><span class="pre">x</span></tt> becomes a cell, not a Scheme object),
and attach metadata to the cells they bind.</p>
<p>Since <tt class="docutils literal"><span class="pre">let-cells</span></tt> is plural (where <tt class="docutils literal"><span class="pre">let</span></tt> was number-neutral), I
also defined <tt class="docutils literal"><span class="pre">let-cell</span></tt> for the case when you just want to make one
cell:</p>
<pre class="literal-block">
(let-cell x ...)              ==&gt;  (let-cells (x) ...)
(let-cell (x (e:+ y z)) ...)  ==&gt;  (let-cells ((x (e:+ y z))) ...)
</pre>
<p>Scheme-Propagators has no analogues of Scheme's <tt class="docutils literal"><span class="pre">letrec</span></tt> or named
<tt class="docutils literal"><span class="pre">let</span></tt> syntax.  Any suggestions on what they would be like and for in
this world?</p>
<p>Finally, there is one more way to make cells that you've also already
met, but maybe didn't recognize.  All the <tt class="docutils literal"><span class="pre">e:</span></tt> and <tt class="docutils literal"><span class="pre">ce:</span></tt>
procedures make and return cells to hold the &quot;outputs&quot; of their
underlying <tt class="docutils literal"><span class="pre">p:</span></tt> and <tt class="docutils literal"><span class="pre">c:</span></tt> variants.  These implicit cells are just
like the implicit memory locations that Scheme creates under the hood
for holding the return values of expressions before they get used by
the next expression or assigned to variables.</p>
</div>
</div>
<div class="section" id="making-new-compound-propagators">
<h1><a class="toc-backref" href="#id10">Making New Compound Propagators</a></h1>
<p>So, you know the primitives (the supplied propagators) and the means
of combination (how to make cells and wire bunches of propagators up
into networks).  Now for the means of abstraction.  A procedure like
<tt class="docutils literal"><span class="pre">p:+</span></tt> is like a wiring diagram with a few holes where it can be
attached to other structures.  Supply that procedure with cells,
and it makes an actual propagator for addition whose inputs and outputs
are those cells.  How do you make compound such procedures?</p>
<p>Well, you can always just use the underlying Scheme:</p>
<pre class="literal-block">
(define (my-diagram x y z)
  (p:+ x y z)
  (p:- z y x)
  (p:- z x y))
</pre>
<p>Then <tt class="docutils literal"><span class="pre">my-diagram</span></tt> would be almost like <tt class="docutils literal"><span class="pre">p:+</span></tt>, in that it would
also be a Scheme variable bound to a Scheme procedure that, if given
three cells, would construct some propagators attached to those cells.
<tt class="docutils literal"><span class="pre">p:+</span></tt> does a little more than that basic job, however, so you should
use <tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt> instead of <tt class="docutils literal"><span class="pre">define</span></tt>:</p>
<pre class="literal-block">
(define-macro-propagator (my-diagram x y z)
  (p:+ x y z)
  (p:- z y x)
  (p:- z x y))
</pre>
<p>makes a much nicer <tt class="docutils literal"><span class="pre">my-diagram</span></tt> that, in addition to doing the basic
job you would expect, also keeps track of metadata that is very helpful
for debugging (namely that the adder and two subtractors inside were
created by a <tt class="docutils literal"><span class="pre">my-diagram</span></tt> rather than just hanging out), and performs
constant conversion on its inputs, so you can write:</p>
<pre class="literal-block">
(my-diagram x 3 z)
</pre>
<p>and get</p>
<pre class="literal-block">
(my-diagram x (e:constant 3) z)
</pre>
<p>The Scheme macro <tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt> is called that because
the object it creates is not first-class in Scheme-Propagators.  At
the moment, Scheme-Propagators has no (stable) first-class
representation of wiring diagrams; so all abstraction is effectively
at the level of &quot;macros&quot;, and <tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt> is part of
that system.  But the only &quot;macroness&quot; about it, really, is that the
resulting <tt class="docutils literal"><span class="pre">my-diagram</span></tt> does not and cannot live in a cell.</p>
<div class="section" id="recursion">
<h2><a class="toc-backref" href="#id11">Recursion</a></h2>
<p>Propagator abstractions defined by <tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt> have
one flaw: they are expanded immediately when Scheme encounters them.
Therefore, they cannot be used to build recursive structures, because
the structure would be expanded infinitely far.  For this purpose,
there is <tt class="docutils literal"><span class="pre">define-compound-propagator</span></tt>.  It's just like
<tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt>, except that the expansion of the wiring
diagram represented by the resulting Scheme procedure is delayed until
some (however partial) information shows up on at least one of the
cells that the diagram is attached to.  For example, a diagram for
computing factorials:</p>
<pre class="literal-block">
(define-compound-propagator (p:factorial n n!)
  (let-cells* ((done? (e:= 0 n))
               (n-again (e:switch (e:not done?) n))
               (n!-again (e:* n-again (e:factorial (e:- n-again 1)))))
    (conditional done? 1 n!-again n!)))

(define e:factorial (functionalize p:factorial))
</pre>
<p>contains a call to itself; but attaching this to some cells will not
cause an immediate infinite regress because the internal <tt class="docutils literal"><span class="pre">factorial</span></tt>
will only expand dynamically during the execution of the network, and
only if it has information to process (preventing spurious recursions
is what the <tt class="docutils literal"><span class="pre">switch</span></tt> and <tt class="docutils literal"><span class="pre">n-again</span></tt> is for).</p>
<p>Much the same effect can be achieved procedurally using the Scheme
procedure <tt class="docutils literal"><span class="pre">delayed-propagator-constructor</span></tt>.</p>
<p>In principle, there is no propagator abstraction that you can express
with <tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt> that you cannot express better with
<tt class="docutils literal"><span class="pre">define-compound-propagator</span></tt>.  However, I still advise
<tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt> where possible, because
<tt class="docutils literal"><span class="pre">define-compound-propagator</span></tt> is more complex, and less stable.
Specifically, while it's pretty clear that <tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt>
is pretty much the right way to make a &quot;propagator macro&quot;, it is not
at all clear whether <tt class="docutils literal"><span class="pre">define-compound-propagator</span></tt> is the right
implementation of the idea of &quot;propagator closure&quot;.</p>
</div>
<div class="section" id="expressions">
<h2><a class="toc-backref" href="#id12">Expressions</a></h2>
<p>The example diagram called <tt class="docutils literal"><span class="pre">my-diagram</span></tt> above should probably have
been named <tt class="docutils literal"><span class="pre">p:my-diagram</span></tt>, because its expects to get all of its
boundary cells when called, and the Scheme procedure does not return
anything useful.  You can mechanically convert <tt class="docutils literal"><span class="pre">p:</span></tt>-type procedures that
you define into <tt class="docutils literal"><span class="pre">e:</span></tt>-type versions with the Scheme procedure
<tt class="docutils literal"><span class="pre">functionalize</span></tt>:</p>
<pre class="literal-block">
(define e:my-diagram (functionalize p:my-diagram))
(define-cell z (e:my-diagram x y))
</pre>
<p>will do what you expect.</p>
</div>
<div class="section" id="macrology">
<h2><a class="toc-backref" href="#id13">Macrology</a></h2>
<p>Sometimes you will need to make something that looks more like a macro
to Scheme-Propagators than the things <tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt> is
for.  After all, the procedures produced by
<tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt> will not only assume that their arguments
are all cells, but will actively coerce them into cells.  For extreme
cases there's always Scheme's <tt class="docutils literal"><span class="pre">define</span></tt>; but sometimes you want the
debugging data provided by <tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt> but not the
constant conversion.  A common use case is variable-arity network
diagrams.  You need a list of cells rather than a single cell, and you
want to use Scheme's <tt class="docutils literal"><span class="pre">map</span></tt> or <tt class="docutils literal"><span class="pre">for-each</span></tt> to do something to them,
but you still want the debugging aids that <tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt>
provides and <tt class="docutils literal"><span class="pre">define</span></tt> does not.  This is what
<tt class="docutils literal"><span class="pre">define-propagator-syntax</span></tt> is for.  The classic example is
<tt class="docutils literal"><span class="pre">require-distinct</span></tt>:</p>
<pre class="literal-block">
(define-propagator-syntax (require-distinct cells)
  (for-each-distinct-pair
   (lambda (c1 c2)
     (define-cell p)
     (=? c1 c2 p)
     (forbid p))
   cells))
</pre>
</div>
</div>
<div class="section" id="using-partial-information">
<h1><a class="toc-backref" href="#id14">Using Partial Information</a></h1>
<p>Partial, accumulatable information is the other side of the coin of
multidirectional, nonsequential programming, so Scheme-Propagators is
all about partial information.  What do I mean by that?  Each &quot;memory
location&quot; of Scheme-Propagators, that is each cell, maintains not &quot;a
value&quot;, but &quot;all the information it has about a value&quot;.  Such
information may be as little as &quot;I know absolutely nothing about my
value&quot;, as much as &quot;I know everything there is to know about my value,
and it is <tt class="docutils literal"><span class="pre">x</span></tt>&quot;, and many possible variations in between; and also
one not-in-between variation, which is &quot;Stop the presses!  I know
there is a contradiction!&quot;</p>
<p>All these various possible states of information are represented (per
force) as Scheme objects.  The Scheme object <tt class="docutils literal"><span class="pre">nothing</span></tt> represents
the information &quot;I don't know anything&quot;.  This only takes a single
Scheme object, because not knowing anything is a single state of
knowledge.  Most Scheme objects represent &quot;perfect, consistent&quot;
information: the Scheme object <tt class="docutils literal"><span class="pre">5</span></tt> represents the information &quot;I
know everything there is to know, and the answer is <tt class="docutils literal"><span class="pre">5</span></tt>.&quot;  There are
also several Scheme types provided with the system that denote
specific other states of knowledge, and you can make your own.  For
example, objects of type <tt class="docutils literal"><span class="pre">interval?</span></tt> contain an upper bound and a
lower bound, and represent information of the form &quot;I know by value is
between this real number and that one.&quot;</p>
<p>The way to get partial knowledge into the network is to put it into
cells with <tt class="docutils literal"><span class="pre">add-content</span></tt> or constant propagators.  For example:</p>
<pre class="literal-block">
(define-cell x (make-interval 3 5))
</pre>
<p>produces a cell named <tt class="docutils literal"><span class="pre">x</span></tt> that now holds the partial information
<tt class="docutils literal"><span class="pre">(make-interval</span> <span class="pre">3</span> <span class="pre">5)</span></tt>, which means that its notional value is
between <tt class="docutils literal"><span class="pre">3</span></tt> and <tt class="docutils literal"><span class="pre">5</span></tt>.</p>
<p>Partial information structures are generally built to be contagious,
so that once you've inserted a structure of a certain type into
the network, the normal propagators will generally produce answers
in kind, and, if needed, coerce their inputs into the right form
to co-operate.  For example, if <tt class="docutils literal"><span class="pre">x</span></tt> has an interval like above,</p>
<pre class="literal-block">
(define-cell y (e:+ x 2))
</pre>
<p>will make an adder that will eventually need to add <tt class="docutils literal"><span class="pre">2</span></tt> to the
interval between <tt class="docutils literal"><span class="pre">3</span></tt> and <tt class="docutils literal"><span class="pre">5</span></tt>.  This is a perfectly reasonable
thing to ask, because both <tt class="docutils literal"><span class="pre">2</span></tt> and <tt class="docutils literal"><span class="pre">(make-interval</span> <span class="pre">3</span> <span class="pre">5)</span></tt> are
states of knowledge about the inputs to that adder, so it ought to
produce the best possible representation of the knowledge it can
deduce about the result of the addition.  In this case, that would be
the interval between <tt class="docutils literal"><span class="pre">5</span></tt> and <tt class="docutils literal"><span class="pre">7</span></tt>:</p>
<pre class="literal-block">
(run)
(content y)  ==&gt;  #(interval 5 7)
</pre>
<p>The key thing about partial information is, of course, that it's
cumulative.  So if you also added some other knowledge to the <tt class="docutils literal"><span class="pre">y</span></tt>
cell, it would need to merge with the interval that's there to
represent the complete knowledge available as a result:</p>
<pre class="literal-block">
(add-content y (make-interval 4 6))
(content y)  ==&gt;  #(interval 5 6)
</pre>
<p>If incoming knowledge hopelessly contradicts the knowledge a cell
already has, it will complain:</p>
<pre class="literal-block">
(add-content y 15)  ==&gt;  Error
</pre>
<p>stop the network mid-stride, and give you a chance to examine the
situation so you can debug the program that led to it, using the
standard MIT Scheme debugging facilities.</p>
<p>TODO Documentation of provided partial information types</p>
<ul class="simple">
<li>nothing</li>
<li>just a value</li>
<li>intervals</li>
<li>supported values</li>
<li>truth maintenance systems</li>
<li>cons cells (in flux)</li>
</ul>
</div>
<div class="section" id="making-new-kinds-of-partial-information">
<h1><a class="toc-backref" href="#id15">Making New Kinds of Partial Information</a></h1>
<p>There are three components to making your own types of partial
information.  The zeroth is to define the appropriate data structure,
of course.</p>
<div class="section" id="define-your-merge-handlers">
<h2><a class="toc-backref" href="#id16">Define your Merge Handlers</a></h2>
<p>The first is to teach cells how to merge your partial information
structure.  This you do by adding methods to the generic procedure
<tt class="docutils literal"><span class="pre">merge</span></tt>.  Method addition is done with the <tt class="docutils literal"><span class="pre">defhandler</span></tt>
procedure:</p>
<pre class="literal-block">
(defhandler operation handler arg-predicate ...)
</pre>
<p>The generic operations system is a predicate dispatch system.  Every
handler is keyed by a bunch of predicates that must accept the
arguments to the generic procedure in turn; if they do, that handler
is invoked.  For example, merging two intervals with each other
can be defined as:</p>
<pre class="literal-block">
(defhandler merge intersect-intervals interval? interval?)
</pre>
<p>Two important things not to forget: First, if the incoming information
(second argument to the <tt class="docutils literal"><span class="pre">merge</span></tt> generic procedure) is redundant, you
must return identically the first argument, because cells check with
<tt class="docutils literal"><span class="pre">eq?</span></tt> whether their information changed.  Presumably the
<tt class="docutils literal"><span class="pre">intersect-intervals</span></tt> procedure above arranges this internally.
(The Scheme procedure <tt class="docutils literal"><span class="pre">eq?-standardizing</span></tt> is provided as a useful
combinator for this purpose -- type <tt class="docutils literal"><span class="pre">(pp</span> <span class="pre">eq?-standardizing)</span></tt> at a prompt
after loading the Scheme-Propagators system).  If you get this wrong,
your networks will tend to enter infinite loops.  Second, it is your
responsibility to make sure that your partial information structure
merges well with all other partial information structures that it can
encounter in a cell.  Intervals, for example, should handle raw
numbers, because knowing that something is exactly <tt class="docutils literal"><span class="pre">2</span></tt> is compatible
with knowing that it is between <tt class="docutils literal"><span class="pre">1</span></tt> and <tt class="docutils literal"><span class="pre">3</span></tt>.  In the case of
intervals, I defined the procedure <tt class="docutils literal"><span class="pre">ensure-inside</span></tt> to either
return the number if it is in the interval, or return a contradiction
object if it is not, and attached it as a handler with</p>
<pre class="literal-block">
(defhandler merge ensure-inside interval? number?)

(defhandler merge
 (lambda (content increment)
   (ensure-inside increment content))
 number? interval?)
</pre>
<p>Speaking of which, <tt class="docutils literal"><span class="pre">merge</span></tt> is allowed to return a special object
called <tt class="docutils literal"><span class="pre">the-contradiction</span></tt> to indicate a complete contradiction
(that should result in an immediate error).</p>
<p>TODO Document the extant partial information structures and the
default mechanisms they use for interacting with others (namely the
<tt class="docutils literal"><span class="pre">nothing?</span> <span class="pre">any?</span></tt> handlers, the <tt class="docutils literal"><span class="pre">flat?</span></tt> predicate, the general
bevaior of TMSes, maybe also the cons story).</p>
</div>
<div class="section" id="define-your-contradiction-test">
<h2><a class="toc-backref" href="#id17">Define your Contradiction Test</a></h2>
<p>There is a generic procedure called <tt class="docutils literal"><span class="pre">contradictory?</span></tt> to which you
can also attach handlers for your partial information structures.  The
<tt class="docutils literal"><span class="pre">contradictory?</span></tt> procedure is called by cells on new merge results
every time they are created, and if it ever returns true, the cell
signals an error immediately.  For example, a strictly empty interval
implies an impossible state of knowledge:</p>
<pre class="literal-block">
(defhandler contradictory? empty-interval? interval?)
;; N.B. empty-interval? is the handler; interval? is the only predicate
</pre>
<p>which means that every interval will be checked by the
<tt class="docutils literal"><span class="pre">empty-interval?</span></tt> procedure to test whether it represents a
contradiction.</p>
</div>
<div class="section" id="augment-the-propagators">
<h2><a class="toc-backref" href="#id18">Augment the Propagators</a></h2>
<p>In addition to teaching cells how to support your partial information
type, you must also teach the appropriate propagators about it.  Every
primitive propagator that you expect to interact with your partial
information must know how to handle it.  The compound propagators are
ok because they just pass stuff along to the primitives they are
eventually composed of, but the primitives must be taught.</p>
<p>There are two mechanisms of doing this.  Most (TODO document which)
primitive propagators are actually generic Scheme functions
underneath, so you can add handlers to them just like you add handlers
to <tt class="docutils literal"><span class="pre">merge</span></tt>.  See <tt class="docutils literal"><span class="pre">core/intervals.scm</span></tt> for an example of how this
is done with intervals.  Don't forget to teach the propagators what to
do if they encounter your partial information structure on one input
and a different one on another --- if both represent states of
knowledge about compatible ultimate values, it should be possible to
produce a state of knowledge about the results of the computation
(though in extreme cases that state of knowledge might be <tt class="docutils literal"><span class="pre">nothing</span></tt>,
implying no new information produced by the propagator).</p>
<p>Also, most (TODO document which) primitive propagators are wrapped
with the <tt class="docutils literal"><span class="pre">nary-unpacking</span></tt> wrapper function around their underlying
generic operation.  This wrapper function is a poor man's
implementation of monads, so if your partial information structure is
essentially monadic, you can use this to teach all propagators how to
handle it.</p>
<p>Unfortunately, I understand neither partial information nor monads as
well as I would like, so this mechanism is a bit nasty.  To use it,
you must define methods for the generic procedures <tt class="docutils literal"><span class="pre">generic-unpack</span></tt>
and <tt class="docutils literal"><span class="pre">generic-flatten</span></tt>, which are a not-necessarily-good
decomposition of the usual monadic <tt class="docutils literal"><span class="pre">bind</span></tt> operation.  The <tt class="docutils literal"><span class="pre">bind</span></tt>
is an <tt class="docutils literal"><span class="pre">unpack</span></tt> followed by a <tt class="docutils literal"><span class="pre">flatten</span></tt>.  <tt class="docutils literal"><span class="pre">generic-unpack</span></tt> takes
your partial information structure and a function that wants the
goodie inside, is expected to call that function with whatever values
it wants, and to produce the result of the function, partial in the
way appropriate to your partial information.  Subsequently,
<tt class="docutils literal"><span class="pre">generic-flatten</span></tt> is called on the result, to allow you to sanitize
it; for example, to turn a truth maintenance system that now
(directly) contains a truth maintenance system into just one single
truth maintenance system.</p>
<p>If this helps, the type signatures of <tt class="docutils literal"><span class="pre">generic-unpack</span></tt> and
<tt class="docutils literal"><span class="pre">generic-flatten</span></tt> would be:</p>
<pre class="literal-block">
generic-unpack: M a --&gt; (a --&gt; b) --&gt; M b
generic-flatten: M M a --&gt; M a
</pre>
<p>except for two things: I tried to allow the underlying system to be a
bit sloppy with its types, and to rely on coercions to correct the
sloppiness; so the result is that a function being unpacked into is
free to return whatever it wants, and you are expected to take care of
it in <tt class="docutils literal"><span class="pre">generic-flatten</span></tt>; and I tried to make the partial information
types compose, so the thing that's really going on is that there is
one big monad that you are adding to.  I don't know whether this is a
reimplementation of the monad transformers story, because no one has
ever explained that story to me in such a way that I got it.</p>
<p>In any case, this mechanism is something of a mess.  See
<tt class="docutils literal"><span class="pre">core/supported-values.scm</span></tt> and <tt class="docutils literal"><span class="pre">core/truth-maintenance.scm</span></tt> for
examples of how it can be used; and maybe talk to me when you set out
to make a partial information structure.</p>
</div>
</div>
<div class="section" id="debugging">
<h1><a class="toc-backref" href="#id19">Debugging</a></h1>
<p>There is no stand-alone &quot;propagator debugger&quot;; if something goes
wrong, the underlying Scheme debugger is your friend.  Some effort
has, however, been expended on making your life easier.</p>
<p>In normal operation, Scheme-Propagators keeps track of some metadata
about the network that is running.  This metadata can be invaluable
for debugging propagator networks.  The specific data it tries to
track is:</p>
<ul class="simple">
<li>The names (non-unique but semantic) of all the cells and
propagators.  This is in contast with the unique but non-semantic
object hashes of all the cells and propagators that MIT Scheme
tracks anyway.</li>
<li>Which propagators are connected to which cells.</li>
<li>Whether the connections are input, output, or both.</li>
<li>The grouping structure of the propagator network, as defined
by the call structure of the Scheme procedures that constructed it.</li>
</ul>
<p>To make sure that your network tracks this metadata well, you should
use the high level interfaces to making cells, propagators, and
propagator constructors when possible (<tt class="docutils literal"><span class="pre">define-cell</span></tt>, <tt class="docutils literal"><span class="pre">let-cells</span></tt>,
<tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt>, <tt class="docutils literal"><span class="pre">propagatify</span></tt>, etc).  Any gaps not
filled by use of these interfaces must either be accepted as gaps or
be filled by hand.</p>
<p>Perhaps the most spectacular use of the metadata facility is to
draw pictures of your propagator network.  Just type:</p>
<pre class="literal-block">
(draw:show-graph)
</pre>
<p>at the REPL and watch what happens!  If the picture does not look like
the graph you thought you made, make sure the connection metadata is
collected appropriately, but then check your code to see whether you
miswired something.  If the picture contains useless gibberish in the
labels, make sure the names of things are correctly assigned and
tracked.  If <tt class="docutils literal"><span class="pre">dot</span></tt> crashes, maybe your network is too big for it.
For more on various pictures you can draw, look in the source comments
in <tt class="docutils literal"><span class="pre">extensions/draw.scm</span></tt>.</p>
<p>Of course, in order to use the metadata for debugging, you must be
able to read it.  Inspection procedures using the metadata are provided:</p>
<dl class="docutils">
<dt>name</dt>
<dd>the name of an object, should it have one</dd>
<dt>cell?</dt>
<dd>whether something is a cell or not</dd>
<dt>propagator?</dt>
<dd>whether something is a propagator or not</dd>
<dt>propagator-inputs</dt>
<dd>the inputs of a propagator (a list of cells)</dd>
<dt>propagator-outputs</dt>
<dd>the outputs of a propagator (a list of cells)</dd>
<dt>neighbors</dt>
<dd>the readers of a cell (a list of propagators)</dd>
<dt>cell-non-readers</dt>
<dd>other propagators somehow associated with a cell (presumably ones that write to it)</dd>
<dt>cell-connections</dt>
<dd>all propagators around a cell (the append of the neighbors
and the non-readers)</dd>
<dt>network-group-of</dt>
<dd>a metadata object representing the context in which
the object being examined was created (see <tt class="docutils literal"><span class="pre">core/metadata.scm</span></tt>
to learn what you can do with them)</dd>
</dl>
<p>You can use these at least somewhat to wander around a network you are
debugging.  Be advised that both cells and propagators are represented
directly as Scheme procedures, and therefore do not print very nicely
at the REPL.</p>
<p>If you find yourself doing something strange that circumvents the
usual metadata tracking mechanisms, you can add the desired metadata
yourself.  All the metadata collection procedures are defined in
<tt class="docutils literal"><span class="pre">core/metadata.scm</span></tt>; they generally use the <tt class="docutils literal"><span class="pre">eq-properties</span></tt>
mechanism in <tt class="docutils literal"><span class="pre">support/eq-properties.scm</span></tt> to track the metadata, so
you can use it to add more.  In particular, see the definition of, say,
<tt class="docutils literal"><span class="pre">function-&gt;propagator-constructor</span></tt> or <tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt>
for examples of how this is done.</p>
</div>
<div class="section" id="making-new-primitive-propagators">
<h1><a class="toc-backref" href="#id20">Making New Primitive Propagators</a></h1>
<div class="section" id="direct-construction-from-functions">
<h2><a class="toc-backref" href="#id21">Direct Construction from Functions</a></h2>
<p>The fundamental, stable way to make your own primitive propagators is
the procedure <tt class="docutils literal"><span class="pre">function-&gt;propagator-constructor</span></tt>.  It takes a Scheme
function, and makes a propagator construction procedure out of it that
makes a propagator that does the job implemented by that Scheme
function.  The propagator constructor in question takes one more
argument than the original function, the extra argument being the cell
into which to write the output.  So the result of
<tt class="docutils literal"><span class="pre">function-&gt;propagator-constructor</span></tt> is a <tt class="docutils literal"><span class="pre">p:</span></tt>-style procedure
(complete with (most of) the debugging information, and the constant
conversion).  For example, you might define:</p>
<pre class="literal-block">
(define p:my-primitive (function-&gt;propagator-constructor do-it))
</pre>
<p>where <tt class="docutils literal"><span class="pre">do-it</span></tt> is the appropriate Scheme function.</p>
<p>Two things to pay attention to: <tt class="docutils literal"><span class="pre">function-&gt;propagator-constructor</span></tt>
wraps the given function up into a propagator directly, and it is up
to the function itself to handle any interesting partial information
type that might come out of its argument cells.  Notably, <tt class="docutils literal"><span class="pre">nothing</span></tt>
might show up in the arguments of that function when it is called.
Therefore, it may be appropriate the make the function itself generic,
and/or wrap it in <tt class="docutils literal"><span class="pre">nary-unpacking</span></tt>.  For examples, check out how the
provided primitive propagators are implemented, in
<tt class="docutils literal"><span class="pre">core/standard-propagators.scm</span></tt> (which refers to definitions made in
<tt class="docutils literal"><span class="pre">core/generic-definitions.scm</span></tt>).</p>
<p>The second thing is metadata.  <tt class="docutils literal"><span class="pre">function-&gt;propagator-constructor</span></tt>
can supply all the metadata that the debugger uses except the name for
your function.  That you need to add yourself, with <tt class="docutils literal"><span class="pre">(name!</span>
<span class="pre">your-function</span> <span class="pre">'some-name)</span></tt> (see <tt class="docutils literal"><span class="pre">core/generic-definitions.scm</span></tt>).</p>
<div class="section" id="propagator-constructor-combinators">
<h3><a class="toc-backref" href="#id22">Propagator Constructor Combinators</a></h3>
<p>Once you've made a <tt class="docutils literal"><span class="pre">p:</span></tt>-style propagator constructor, you can turn
it into an <tt class="docutils literal"><span class="pre">:e</span></tt>-style one automatically with <tt class="docutils literal"><span class="pre">functionalize</span></tt>.  For
example, <tt class="docutils literal"><span class="pre">e:+</span></tt> is actually defined as:</p>
<pre class="literal-block">
(define e:+ (functionalize p:+))
</pre>
<p>See <tt class="docutils literal"><span class="pre">core/expression-language.scm</span></tt> for more of that.</p>
<p>You can also delay the actual construction of your primitives
if you want with <tt class="docutils literal"><span class="pre">delayed-propagator-constructor</span></tt>, though that's
really more useful with recursive compound propagators.</p>
</div>
</div>
<div class="section" id="dwim-propagator-construction">
<h2><a class="toc-backref" href="#id23">DWIM Propagator Construction</a></h2>
<p>All that wrapping in <tt class="docutils literal"><span class="pre">nary-unpacking</span></tt>, and naming your propagator
functions with <tt class="docutils literal"><span class="pre">name!</span></tt>, and calling <tt class="docutils literal"><span class="pre">functionalize</span></tt> to convert
them to <tt class="docutils literal"><span class="pre">e:</span></tt>-style versions can get tedious.  This whole shebang
is automated by the <tt class="docutils literal"><span class="pre">propagatify</span></tt> macro:</p>
<pre class="literal-block">
(propagatify eq?)
</pre>
<p>turns into</p>
<pre class="literal-block">
(define p:eq?
 (function-&gt;propagator-constructor
  (nary-unpacking (name! eq? 'eq?))))
(define e:eq? (functionalize p:eq?))
</pre>
<p>Use this with some caution; you may not always want <tt class="docutils literal"><span class="pre">nary-unpacking</span></tt>,
and you may not always want to <tt class="docutils literal"><span class="pre">propagatify</span></tt> the raw Scheme function
instead of making a corresponding generic operator.
The macro is defined in <tt class="docutils literal"><span class="pre">core/expression-language.scm</span></tt>, so that's
an example for you if you want to write variants (let me know if you
come across a good one).</p>
</div>
<div class="section" id="fully-manual-low-level-propagator-construction">
<h2><a class="toc-backref" href="#id24">Fully-manual Low-level Propagator Construction</a></h2>
<p>Finally, when the thing you want your propagator to do is so low-level and
interesting that it doesn't even correspond to a Scheme function,
there's always the <tt class="docutils literal"><span class="pre">propagator</span></tt> procedure.  This is the lowest level
interface to asking cells to notify a propagator when they change.
<tt class="docutils literal"><span class="pre">propagator</span></tt> expects a list of cells that your propagator is
interested in, and a thunk that implements the job that propagator is
supposed to do.  The scheduler will execute your thunk from time to
time --- the only promise is that it will run at least once after the
last time any cell in the supplied neighbor list gains any new
information.  For example:</p>
<pre class="literal-block">
(define (my-hairy-thing cell1 cell2)
  (propagator (list cell1 cell2)
    (lambda ()
      do-something-presumably-with-cell1-and-cell2)))
</pre>
<p>The <tt class="docutils literal"><span class="pre">propagator</span></tt> procedure being the lowest possible level, it has
no access to any useful sources of metadata, so you will need to
provide yourself any metadata you want to be able to access later.
For an example of how this facility is used, see the implementations
of <tt class="docutils literal"><span class="pre">function-&gt;propagator-constructor</span></tt> and
<tt class="docutils literal"><span class="pre">delayed-propagator-constructor</span></tt> in <tt class="docutils literal"><span class="pre">core/core.scm</span></tt>.</p>
</div>
</div>
<div class="section" id="miscellany">
<h1><a class="toc-backref" href="#id25">Miscellany</a></h1>
<div class="section" id="implicit-cell-syntax">
<h2><a class="toc-backref" href="#id26">Implicit Cell Syntax</a></h2>
<p>A quirky little feature, called
<tt class="docutils literal"><span class="pre">%%</span></tt>.  This is a Scheme object, therefore Scheme-Propagators syntax,
for controlling the argument position of the implicit cell that an
<tt class="docutils literal"><span class="pre">e:</span></tt> or <tt class="docutils literal"><span class="pre">ce:</span></tt> procedure will make and return.  Perhaps examples
are best:</p>
<pre class="literal-block">
(e: foo bar)     &lt;==&gt;  (e: foo bar %%)

(e: foo %% bar)  &lt;==&gt;  (let-cell new (p: foo new bar) new)
</pre>
<p>I borrowed this idea from Guy Steele's PhD thesis on constraint
languages, and it was a year between when I implemented it and
when I first used it.  The use case I do have is when I
want to make a new cell participate in an input position
in a constraint with some existing cells:</p>
<pre class="literal-block">
(define-cell x)
(define-cell z)
(define-cell y (ce:+ x %% z))
(add-content x 5)
(add-content y 3)
(run)
(content z) ==&gt; 8
</pre>
<p>Perhaps this use case could also be served by adding more
expression-style constraint procedures (namely <tt class="docutils literal"><span class="pre">ce:-</span></tt>, which I do
not currently have), but then again maybe it's elegant.</p>
</div>
<div class="section" id="reboots">
<h2><a class="toc-backref" href="#id27">Reboots</a></h2>
<p>The procedure <tt class="docutils literal"><span class="pre">initialize-scheduler</span></tt> wipes out an existing
propagator network and lets you start afresh:</p>
<pre class="literal-block">
build lots of network
...
(initialize-scheduler)
(run) --- nothing happens; no propagators to run!
</pre>
</div>
<div class="section" id="compiling">
<h2><a class="toc-backref" href="#id28">Compiling</a></h2>
<p>It turns out that <tt class="docutils literal"><span class="pre">make-cell</span></tt> and <tt class="docutils literal"><span class="pre">cell?</span></tt> are also MIT Scheme
primitives, so if you want to compile your Scheme-Propagators
code, be sure to put</p>
<pre class="literal-block">
(declare (usual-integrations make-cell cell?))
</pre>
<p>at the top of your source files.  Also, of course, you need to be
suitably careful to make sure that the defined macros are available to
the syntaxer when it processes your file.  See
<tt class="docutils literal"><span class="pre">support/auto-compilation.scm</span></tt> for how I do this, and, say,
<tt class="docutils literal"><span class="pre">core/load.scm</span></tt> for how I use the compiler.</p>
</div>
<div class="section" id="scmutils">
<h2><a class="toc-backref" href="#id29">Scmutils</a></h2>
<p>The <a class="reference external" href="http://groups.csail.mit.edu/mac/users/gjs/6946/linux-install.htm">Scmutils</a> system built by Gerald Jay Sussman for thinking about
physics can be very useful for many purposes.  Among other things,
it knows about units and dimensions, about symbolic algebra,
about solving systems of equations, etc.  Scheme-Propagators runs
in Scmutils just as well as in MIT Scheme; and some of the unit
tests in the self-test suite rely on Scmutils.</p>
</div>
<div class="section" id="editing">
<h2><a class="toc-backref" href="#id30">Editing</a></h2>
<p>I edit code in Emacs.  Emacs of course has a Scheme mode; nothing more
need be said about that here.</p>
<p>If you are going to edit any parenthesized source code in Emacs,
<a class="reference external" href="http://www.emacswiki.org/emacs/ParEdit">Paredit mode</a> is a godsend.</p>
<p>In addition to the above, I find it very useful to have my editor
highlight and indent some of the Scheme-Propagators macros I have
defined the same way as their Scheme analogues; notably
<tt class="docutils literal"><span class="pre">define-macro-propagator</span></tt> and co, and <tt class="docutils literal"><span class="pre">let-cells</span></tt>.  Sadly the
Emacs Scheme mode does not do this by default, so you need to tweak
the Emacs config to do that.  The file <tt class="docutils literal"><span class="pre">support/scm-propagators.el</span></tt>
contains a dump of the relevant portion of my Emacs configuration.</p>
</div>
<div class="section" id="hacking">
<h2><a class="toc-backref" href="#id31">Hacking</a></h2>
<p>Scheme-Propagators is obviously a work in progress.  Be aware that I
will continue to hack it to my heart's content.  Likewise, feel free
to hack it to yours --- let me know if you invent or implement
something interesting.</p>
<p>TODO Describe where in the source various constructs are defined?  So that
it is possible to mimic them (e.g. more primitive propagators) and/or
adapt them.</p>
</div>
<div class="section" id="todo">
<h2><a class="toc-backref" href="#id32">TODO</a></h2>
<ul class="simple">
<li>How do I want to section up the p:, e:, c:, and ce: ideas?</li>
<li>Advertise the examples/ directory</li>
</ul>
</div>
<div class="section" id="revision-history-of-this-guide">
<h2><a class="toc-backref" href="#id33">Revision History of this Guide</a></h2>
<p>First written May 5, 2010 by Alexey Radul</p>
</div>
</div>
</div>
</body>
</html>
